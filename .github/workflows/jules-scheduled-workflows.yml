# This file is auto-generated. Do not edit manually.
# Jules Agent Orchestration
#
# Orchestrates scheduled/dispatch layer execution in sequence.
# Implementer PR metadata and auto-merge are delegated to dedicated workflows.
# Layer/task orchestration is command-driven through `jlo workflow`.

name: Jules Scheduled Workflows

on:
  schedule:

    - cron: '0 19 * * *'

  workflow_dispatch:
    inputs:
      entry_point:
        description: 'Start from layer'
        type: choice
        options:
          - narrator
          - innovators
          - observers
          - merger
          - planner
          - implementer
        default: narrator
      wait_minutes:
        description: 'Minutes to wait between layers (Jules async processing time)'
        type: number
        default: 30
      mock:
        description: 'Run in mock mode (creates branches/PRs without Jules API)'
        type: boolean
        default: false

permissions: {}

concurrency:
  group: 'jules-orchestration'
  cancel-in-progress: false

env:
  WAIT_MINUTES: ${{ github.event_name == 'workflow_dispatch' && (github.event.inputs.wait_minutes || 30) || 30 }}
  MOCK_MODE: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.mock == 'true' || false }}
  JULES_MOCK_TAG: ${{ format('mock-run-{0}', github.run_id) }}
  JLO_RUN_FLAGS: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.mock == 'true' && '--mock' || '' }}
  JLO_TARGET_BRANCH: 'main'
  JULES_WORKER_BRANCH: 'jules'






jobs:
  # ============================================================
  # Phase 0: Bootstrap runtime repository on worker branch
  # ============================================================
  bootstrap:
    if: >-
      (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch') &&
      ((vars.JLO_PAUSED || 'false') != 'true' || github.event_name != 'schedule')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - name: Validate branch variables
        run: |
          set -euo pipefail
          if [ -z "${JLO_TARGET_BRANCH:-}" ]; then
            echo "::error::JLO_TARGET_BRANCH is required."
            exit 1
          fi
          if [ -z "${JULES_WORKER_BRANCH:-}" ]; then
            echo "::error::JULES_WORKER_BRANCH is required."
            exit 1
          fi

      - uses: actions/checkout@v4
        with:
          ref: 'main'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          token: ${{ secrets.JLO_RELEASE_TOKEN }}
          submodule_token: ${{ secrets.SUBMODULE_PAT }}

      - name: Sync worker branch
        run: jlo workflow bootstrap worker-branch

      - name: Bootstrap managed files
        run: jlo workflow bootstrap managed-files

      - name: Reset narrator changes summary
        run: jlo workflow bootstrap clean-exchange

      - name: Validate repository structure
        run: jlo workflow doctor structure

      - name: Create bootstrap sync PR to worker branch
        id: sync_pr
        run: |
          set -euo pipefail
          pr_body=$(cat <<EOF
          Automated bootstrap update for the runtime workspace.

          - synchronize ${JLO_TARGET_BRANCH} into ${JULES_WORKER_BRANCH} via \`jlo workflow bootstrap worker-branch\`
          - bootstrap managed files via \`jlo workflow bootstrap managed-files\`
          - reset narrator summary via \`jlo workflow bootstrap clean-exchange\`
          EOF
          )
          jlo_version="$(jlo --version | cut -d ' ' -f 2)"
          jlo workflow create-sync-pr \
            --change-token "bootstrap" \
            --commit-message "chore: bootstrap .jules/ runtime repository [jlo ${jlo_version}]" \
            --pr-title "chore: bootstrap runtime workspace" \
            --pr-body "${pr_body}"

      - name: Wait for bootstrap sync PR merge
        if: ${{ fromJSON(steps.sync_pr.outputs.json || '{}').applied == true }}
        env:
          GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
          PR_NUMBER: ${{ fromJSON(steps.sync_pr.outputs.json || '{}').pr_number }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          for _ in $(seq 1 60); do
            merged_at="$(gh pr view "$PR_NUMBER" --repo "$REPO" --json mergedAt -q '.mergedAt')"
            if [ -n "${merged_at}" ] && [ "${merged_at}" != "null" ]; then
              echo "Bootstrap sync PR #$PR_NUMBER merged at ${merged_at}."
              exit 0
            fi

            state="$(gh pr view "$PR_NUMBER" --repo "$REPO" --json state -q '.state')"
            if [ "${state}" = "CLOSED" ]; then
              echo "::error::Bootstrap sync PR #$PR_NUMBER closed without merge."
              exit 1
            fi

            sleep 5
          done

          echo "::error::Timed out waiting for bootstrap sync PR #$PR_NUMBER to merge."
          exit 1


  # ============================================================
  # Phase 1: Resolve run plan
  # ============================================================
  resolve-run-plan:
    needs: [bootstrap]
    if: |
      needs.bootstrap.result == 'success' &&
      ((vars.JLO_PAUSED || 'false') != 'true' || github.event_name != 'schedule') &&
      (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      json: ${{ steps.check.outputs.json }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          token: ${{ secrets.JLO_RELEASE_TOKEN }}
          submodule_token: ${{ secrets.SUBMODULE_PAT }}

      - name: Resolve run plan
        id: check
        env:
          EVENT_NAME: ${{ github.event_name }}
          ENTRY_POINT: ${{ github.event_name == 'workflow_dispatch' && (github.event.inputs.entry_point || 'narrator') || '' }}
        run: |
          set -euo pipefail
          if [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            jlo workflow resolve plan "$EVENT_NAME" --entry-point "$ENTRY_POINT"
          else
            jlo workflow resolve plan "$EVENT_NAME"
          fi


  # ============================================================
  # Phase 2: Run narrator
  # ============================================================

  run-narrator:
    needs: [resolve-run-plan]
    if: |
      !cancelled() &&
      needs.resolve-run-plan.result == 'success' &&
            fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_narrator == true

    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          token: ${{ secrets.JLO_RELEASE_TOKEN }}
          submodule_token: ${{ secrets.SUBMODULE_PAT }}
      - name: Run narrator
        id: run
        run: |
          set -euo pipefail
          jlo workflow exec narrator ${{ env.JLO_RUN_FLAGS }}
  # ============================================================
  # Phase 3: Run innovators
  # ============================================================

  run-innovators:
    needs: [resolve-run-plan]
    if: |
      !cancelled() &&
      needs.resolve-run-plan.result == 'success' &&
            fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_innovators == true

    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          token: ${{ secrets.JLO_RELEASE_TOKEN }}
          submodule_token: ${{ secrets.SUBMODULE_PAT }}
      - name: Run innovators
        id: run
        run: |
          set -euo pipefail
          jlo workflow exec innovators ${{ env.JLO_RUN_FLAGS }} --task create_three_proposals
  # ============================================================
  # Phase 4: Wait for innovators processing
  # ============================================================

  wait-after-run-innovators:
    needs: ["run-innovators"]
    if: |
      !cancelled() &&
      always() &&
      needs.run-innovators.result == 'success' &&
      fromJSON(needs.run-innovators.outputs.json || '{"number_of_api_requests_succeeded":0}').number_of_api_requests_succeeded > 0
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        id: wait
        shell: bash
        run: |
          set -euo pipefail
          SLEEP_PID=""
          on_cancel() {
            echo "Cancellation detected. Exiting wait early."
            if [ -n "$SLEEP_PID" ]; then
              kill "$SLEEP_PID" 2>/dev/null || true
              wait "$SLEEP_PID" 2>/dev/null || true
            fi
            exit 130
          }
          trap on_cancel INT TERM
          if [ "${{ env.MOCK_MODE }}" = "true" ]; then
            TOTAL_SECONDS=15
            echo "Mock mode enabled: overriding wait to 15 seconds."
          else
            TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
          fi

          if [ "$TOTAL_SECONDS" -le 0 ]; then
            echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
            echo "json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process innovators..."
          # Foreground sleep delays trap handling until sleep returns in bash.
          # Use background sleep + wait so cancellation signals are processed immediately.
          sleep "$TOTAL_SECONDS" &
          SLEEP_PID=$!
          wait "$SLEEP_PID"
          echo "Wait complete."
          echo "json={}" >> "$GITHUB_OUTPUT"
  # ============================================================
  # Phase 5: Publish innovators proposals
  # ============================================================
  publish-proposals:
    needs: [wait-after-run-innovators]
    if: |
      needs.wait-after-run-innovators.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          token: ${{ secrets.JLO_RELEASE_TOKEN }}
          submodule_token: ${{ secrets.SUBMODULE_PAT }}

      - name: Publish proposals
        run: jlo workflow publish-proposals

      - name: Validate structure
        run: jlo workflow doctor structure

      - name: Create published proposal cleanup sync PR
        run: |
          set -euo pipefail
          if [ -z "$(git status --porcelain .jules)" ]; then
            echo "No proposal cleanup changes detected."
            exit 0
          fi
          jlo workflow create-sync-pr \
            --change-token "publish-proposals" \
            --commit-message "jules: publish innovator proposals" \
            --pr-title "chore: publish innovator proposals" \
            --pr-body "Automated publication cleanup for innovator proposals."

  # ============================================================
  # Phase 6: Wait after narrator
  # ============================================================

  wait-after-narrator:
    needs: ["resolve-run-plan", "run-narrator"]
    if: |
      !cancelled() &&
      always() &&
      needs.resolve-run-plan.result == 'success' &&
      (
        (
          fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_narrator == true &&
          needs.run-narrator.result == 'success'
        ) ||
        (
          fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_narrator == false &&
          needs.run-narrator.result == 'skipped'
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    env:
      WAIT_REQUESTED: ${{ fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_narrator == true && needs.run-narrator.result == 'success' && fromJSON(needs.run-narrator.outputs.json || '{"number_of_api_requests_succeeded":0}').number_of_api_requests_succeeded > 0 }}
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        id: wait
        shell: bash
        run: |
          set -euo pipefail
          SLEEP_PID=""
          on_cancel() {
            echo "Cancellation detected. Exiting wait early."
            if [ -n "$SLEEP_PID" ]; then
              kill "$SLEEP_PID" 2>/dev/null || true
              wait "$SLEEP_PID" 2>/dev/null || true
            fi
            exit 130
          }
          trap on_cancel INT TERM

          if [ "$WAIT_REQUESTED" != "true" ]; then
            TOTAL_SECONDS=0
            echo "Narrator wait not required; skipping wait."
          elif [ "${{ env.MOCK_MODE }}" = "true" ]; then
            TOTAL_SECONDS=15
            echo "Mock mode enabled: overriding wait to 15 seconds."
          else
            TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
          fi

          if [ "$TOTAL_SECONDS" -le 0 ]; then
            echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
            echo "json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process narrator..."
          sleep "$TOTAL_SECONDS" &
          SLEEP_PID=$!
          wait "$SLEEP_PID"
          echo "Wait complete."
          echo "json={}" >> "$GITHUB_OUTPUT"
  # ============================================================
  # Phase 7: Resolve and run observers (matrix)
  # ============================================================

  resolve-observers-matrix:
    needs: ["wait-after-narrator"]
    if: |
      !cancelled() &&
      needs.wait-after-narrator.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      json: ${{ steps.resolve.outputs.json }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          token: ${{ secrets.JLO_RELEASE_TOKEN }}
          submodule_token: ${{ secrets.SUBMODULE_PAT }}

      - name: Resolve observers targets
        id: resolve
        run: |
          set -euo pipefail
          if [ "${MOCK_MODE}" = "true" ]; then
            jlo workflow resolve matrix --layer observers --mock --mock-target-count 3
          else
            jlo workflow resolve matrix --layer observers
          fi

  run-observers:
    needs: ["resolve-run-plan", "resolve-observers-matrix"]
    if: |
      !cancelled() &&
      fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_observers == true &&
      needs.resolve-observers-matrix.result == 'success' &&
      fromJSON(needs.resolve-observers-matrix.outputs.json || '{"count":0,"skipped_count":0,"matrix":[]}').count > 0
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # Jules API session creation requests must run strictly one-by-one.
    # Keep max-parallel fixed to 1; worker limits are enforced by target truncation at matrix-resolution time.
    # The matrix is kept for visibility of resolved target count in the GitHub Actions GUI.
    strategy:
      matrix:
        include: ${{ fromJSON(needs.resolve-observers-matrix.outputs.json || '{"count":0,"skipped_count":0,"matrix":[]}').matrix }}
      max-parallel: 1
      fail-fast: false
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          token: ${{ secrets.JLO_RELEASE_TOKEN }}
          submodule_token: ${{ secrets.SUBMODULE_PAT }}

      - name: Run observers (${{ matrix.target }})
        id: run
        run: |
          set -euo pipefail
          jlo workflow exec observers --target "${{ matrix.target }}" ${{ env.JLO_RUN_FLAGS }}
  # ============================================================
  # Phase 8: Wait after observers
  # ============================================================

  wait-after-observers:
    needs: ["resolve-run-plan", "resolve-observers-matrix", "run-observers"]
    if: |
      !cancelled() &&
      always() &&
      needs.resolve-run-plan.result == 'success' &&
      (
        (
          fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_observers == true &&
          needs.run-observers.result == 'success'
        ) ||
        (
          fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_observers == false &&
          needs.run-observers.result == 'skipped'
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    env:
      WAIT_REQUESTED: ${{ fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_observers == true && needs.run-observers.result == 'success' && fromJSON(needs.resolve-observers-matrix.outputs.json || '{"count":0,"skipped_count":0,"matrix":[]}').count > 0 }}
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        id: wait
        shell: bash
        run: |
          set -euo pipefail
          SLEEP_PID=""
          on_cancel() {
            echo "Cancellation detected. Exiting wait early."
            if [ -n "$SLEEP_PID" ]; then
              kill "$SLEEP_PID" 2>/dev/null || true
              wait "$SLEEP_PID" 2>/dev/null || true
            fi
            exit 130
          }
          trap on_cancel INT TERM

          if [ "$WAIT_REQUESTED" != "true" ]; then
            TOTAL_SECONDS=0
            echo "Observers wait not required; skipping wait."
          elif [ "${{ env.MOCK_MODE }}" = "true" ]; then
            TOTAL_SECONDS=15
            echo "Mock mode enabled: overriding wait to 15 seconds."
          else
            TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
          fi

          if [ "$TOTAL_SECONDS" -le 0 ]; then
            echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
            echo "json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process observers..."
          sleep "$TOTAL_SECONDS" &
          SLEEP_PID=$!
          wait "$SLEEP_PID"
          echo "Wait complete."
          echo "json={}" >> "$GITHUB_OUTPUT"
  # ============================================================
  # Phase 9: Run merger
  # ============================================================

  run-merger:
    needs: ["resolve-run-plan", "wait-after-observers"]
    if: |
      !cancelled() &&
      needs.resolve-run-plan.result == 'success' &&
            fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_merger == true

    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          token: ${{ secrets.JLO_RELEASE_TOKEN }}
          submodule_token: ${{ secrets.SUBMODULE_PAT }}
      - name: Run merger
        id: run
        run: |
          set -euo pipefail
          jlo workflow exec merger ${{ env.JLO_RUN_FLAGS }}
  # ============================================================
  # Phase 10: Wait after merger
  # ============================================================

  wait-after-merger:
    needs: ["resolve-run-plan", "run-merger"]
    if: |
      !cancelled() &&
      always() &&
      needs.resolve-run-plan.result == 'success' &&
      (
        (
          fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_merger == true &&
          needs.run-merger.result == 'success'
        ) ||
        (
          fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_merger == false &&
          needs.run-merger.result == 'skipped'
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    env:
      WAIT_REQUESTED: ${{ fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_merger == true && needs.run-merger.result == 'success' && fromJSON(needs.run-merger.outputs.json || '{"number_of_api_requests_succeeded":0}').number_of_api_requests_succeeded > 0 }}
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        id: wait
        shell: bash
        run: |
          set -euo pipefail
          SLEEP_PID=""
          on_cancel() {
            echo "Cancellation detected. Exiting wait early."
            if [ -n "$SLEEP_PID" ]; then
              kill "$SLEEP_PID" 2>/dev/null || true
              wait "$SLEEP_PID" 2>/dev/null || true
            fi
            exit 130
          }
          trap on_cancel INT TERM

          if [ "$WAIT_REQUESTED" != "true" ]; then
            TOTAL_SECONDS=0
            echo "Merger wait not required; skipping wait."
          elif [ "${{ env.MOCK_MODE }}" = "true" ]; then
            TOTAL_SECONDS=15
            echo "Mock mode enabled: overriding wait to 15 seconds."
          else
            TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
          fi

          if [ "$TOTAL_SECONDS" -le 0 ]; then
            echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
            echo "json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process merger..."
          sleep "$TOTAL_SECONDS" &
          SLEEP_PID=$!
          wait "$SLEEP_PID"
          echo "Wait complete."
          echo "json={}" >> "$GITHUB_OUTPUT"
  # ============================================================
  # Phase 11: Resolve and run planner (matrix)
  # ============================================================

  resolve-planner-matrix:
    needs: ["wait-after-merger"]
    if: |
      !cancelled() &&
      needs.wait-after-merger.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      json: ${{ steps.resolve.outputs.json }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          token: ${{ secrets.JLO_RELEASE_TOKEN }}
          submodule_token: ${{ secrets.SUBMODULE_PAT }}

      - name: Resolve planner targets
        id: resolve
        run: |
          set -euo pipefail
          if [ "${MOCK_MODE}" = "true" ]; then
            jlo workflow resolve matrix --layer planner --mock --mock-target-count 2
          else
            jlo workflow resolve matrix --layer planner
          fi

  run-planner:
    needs: ["resolve-run-plan", "resolve-planner-matrix"]
    if: |
      !cancelled() &&
      needs.resolve-run-plan.result == 'success' &&
      fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_planner == true &&
      needs.resolve-planner-matrix.result == 'success' &&
      fromJSON(needs.resolve-planner-matrix.outputs.json || '{"count":0,"skipped_count":0,"matrix":[]}').count > 0
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # Jules API session creation requests must run strictly one-by-one.
    # Keep max-parallel fixed to 1; worker limits are enforced by target truncation at matrix-resolution time.
    # The matrix is kept for visibility of resolved target count in the GitHub Actions GUI.
    strategy:
      matrix:
        include: ${{ fromJSON(needs.resolve-planner-matrix.outputs.json || '{"count":0,"skipped_count":0,"matrix":[]}').matrix }}
      max-parallel: 1
      fail-fast: false
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          token: ${{ secrets.JLO_RELEASE_TOKEN }}
          submodule_token: ${{ secrets.SUBMODULE_PAT }}

      - name: Run planner (${{ matrix.target }})
        id: run
        run: |
          set -euo pipefail
          jlo workflow exec planner --target "${{ matrix.target }}" ${{ env.JLO_RUN_FLAGS }}
  # ============================================================
  # Phase 12: Wait for planner PRs
  # ============================================================

  wait-after-planner:
    needs: ["resolve-planner-matrix", "run-planner"]
    if: |
      !cancelled() &&
      always() &&
      needs.run-planner.result == 'success' &&
      fromJSON(needs.resolve-planner-matrix.outputs.json || '{"count":0,"skipped_count":0,"matrix":[]}').count > 0
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        id: wait
        shell: bash
        run: |
          set -euo pipefail
          SLEEP_PID=""
          on_cancel() {
            echo "Cancellation detected. Exiting wait early."
            if [ -n "$SLEEP_PID" ]; then
              kill "$SLEEP_PID" 2>/dev/null || true
              wait "$SLEEP_PID" 2>/dev/null || true
            fi
            exit 130
          }
          trap on_cancel INT TERM
          if [ "${{ env.MOCK_MODE }}" = "true" ]; then
            TOTAL_SECONDS=15
            echo "Mock mode enabled: overriding wait to 15 seconds."
          else
            TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
          fi

          if [ "$TOTAL_SECONDS" -le 0 ]; then
            echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
            echo "json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process planner..."
          # Foreground sleep delays trap handling until sleep returns in bash.
          # Use background sleep + wait so cancellation signals are processed immediately.
          sleep "$TOTAL_SECONDS" &
          SLEEP_PID=$!
          wait "$SLEEP_PID"
          echo "Wait complete."
          echo "json={}" >> "$GITHUB_OUTPUT"
  # ============================================================
  # Phase 13: Resolve and run implementer (matrix)
  # ============================================================

  resolve-implementer-matrix:
    needs: ["wait-after-planner"]
    if: |
      !cancelled() &&
      needs.wait-after-planner.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      json: ${{ steps.resolve.outputs.json }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          token: ${{ secrets.JLO_RELEASE_TOKEN }}
          submodule_token: ${{ secrets.SUBMODULE_PAT }}

      - name: Resolve implementer targets
        id: resolve
        run: |
          set -euo pipefail
          if [ "${MOCK_MODE}" = "true" ]; then
            jlo workflow resolve matrix --layer implementer --mock --mock-target-count 2
          else
            jlo workflow resolve matrix --layer implementer
          fi

  run-implementer:
    needs: ["resolve-run-plan", "resolve-implementer-matrix"]
    if: |
      !cancelled() &&
      needs.resolve-run-plan.result == 'success' &&
      fromJSON(needs.resolve-run-plan.outputs.json || '{}').run_implementer == true &&
      needs.resolve-implementer-matrix.result == 'success' &&
      fromJSON(needs.resolve-implementer-matrix.outputs.json || '{"count":0,"skipped_count":0,"matrix":[]}').count > 0
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # Jules API session creation requests must run strictly one-by-one.
    # Keep max-parallel fixed to 1; worker limits are enforced by target truncation at matrix-resolution time.
    # The matrix is kept for visibility of resolved target count in the GitHub Actions GUI.
    strategy:
      matrix:
        include: ${{ fromJSON(needs.resolve-implementer-matrix.outputs.json || '{"count":0,"skipped_count":0,"matrix":[]}').matrix }}
      max-parallel: 1
      fail-fast: false
    outputs:
      json: ${{ steps.run.outputs.json }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          token: ${{ secrets.JLO_RELEASE_TOKEN }}
          submodule_token: ${{ secrets.SUBMODULE_PAT }}

      - name: Run implementer (${{ matrix.target }})
        id: run
        run: |
          set -euo pipefail
          jlo workflow exec implementer --target "${{ matrix.target }}" ${{ env.JLO_RUN_FLAGS }} --branch "${JLO_TARGET_BRANCH}"
  # ============================================================
  # Phase 14: Wait for implementer labels
  # ============================================================

  wait-after-implementer:
    needs: ["resolve-implementer-matrix", "run-implementer"]
    if: |
      !cancelled() &&
      always() &&
      needs.run-implementer.result == 'success' &&
      fromJSON(needs.resolve-implementer-matrix.outputs.json || '{"count":0,"skipped_count":0,"matrix":[]}').count > 0
    runs-on: ubuntu-latest
    timeout-minutes: 60
    outputs:
      json: ${{ steps.wait.outputs.json }}
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        id: wait
        shell: bash
        run: |
          set -euo pipefail
          SLEEP_PID=""
          on_cancel() {
            echo "Cancellation detected. Exiting wait early."
            if [ -n "$SLEEP_PID" ]; then
              kill "$SLEEP_PID" 2>/dev/null || true
              wait "$SLEEP_PID" 2>/dev/null || true
            fi
            exit 130
          }
          trap on_cancel INT TERM
          if [ "${{ env.MOCK_MODE }}" = "true" ]; then
            TOTAL_SECONDS=15
            echo "Mock mode enabled: overriding wait to 15 seconds."
          else
            TOTAL_SECONDS=$((${{ env.WAIT_MINUTES }} * 60))
          fi

          if [ "$TOTAL_SECONDS" -le 0 ]; then
            echo "Wait skipped (TOTAL_SECONDS=$TOTAL_SECONDS)."
            echo "json={}" >> "$GITHUB_OUTPUT"
            exit 0
          fi
            echo "Waiting ${TOTAL_SECONDS} seconds for Jules to process implementer..."
          # Foreground sleep delays trap handling until sleep returns in bash.
          # Use background sleep + wait so cancellation signals are processed immediately.
          sleep "$TOTAL_SECONDS" &
          SLEEP_PID=$!
          wait "$SLEEP_PID"
          echo "Wait complete."
          echo "json={}" >> "$GITHUB_OUTPUT"

  # ============================================================
  # Phase 15: Cleanup mock artifacts
  # ============================================================
  cleanup-mock-artifacts:
    needs: [publish-proposals, wait-after-planner, wait-after-implementer]
    if: |
      !cancelled() &&
      always() &&
      (github.event_name == 'workflow_dispatch' && github.event.inputs.mock == 'true')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      GH_TOKEN: ${{ secrets.JLO_BOT_TOKEN }}
      GITHUB_REPOSITORY: ${{ github.repository }}
    steps:
      - name: Validate branch variables
        run: |
          set -euo pipefail
          if [ -z "${JLO_TARGET_BRANCH:-}" ]; then
            echo "::error::JLO_TARGET_BRANCH is required."
            exit 1
          fi
          if [ -z "${JULES_WORKER_BRANCH:-}" ]; then
            echo "::error::JULES_WORKER_BRANCH is required."
            exit 1
          fi

      - uses: actions/checkout@v4
        with:
          ref: 'jules'
          fetch-depth: 0
          token: ${{ secrets.JLO_BOT_TOKEN }}

      - name: Configure Git
        uses: ./.github/actions/configure-git

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          token: ${{ secrets.JLO_RELEASE_TOKEN }}
          submodule_token: ${{ secrets.SUBMODULE_PAT }}

      - name: Cleanup mock artifacts for this run
        run: |
          jlo workflow clean-mock --mock-tag "$JULES_MOCK_TAG"

      - name: Validate repository structure
        run: jlo workflow doctor structure

      - name: Create mock cleanup sync PR
        run: |
          set -euo pipefail
          if [ -z "$(git status --porcelain .jules)" ]; then
            echo "No mock cleanup changes detected."
            exit 0
          fi
          jlo workflow create-sync-pr \
            --change-token "mock-cleanup-${JULES_MOCK_TAG}" \
            --commit-message "jules: cleanup mock artifacts ${JULES_MOCK_TAG}" \
            --pr-title "chore: cleanup mock artifacts ${JULES_MOCK_TAG}" \
            --pr-body "Automated cleanup for mock run ${JULES_MOCK_TAG}."

