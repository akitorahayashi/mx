# Jules Agent Orchestration
#
# Orchestrates sequential execution using matrix strategy with max-parallel=1.
# Each phase reads state, generates a matrix, then executes sequentially.
#
# Narrator runs first to produce changes context, followed by doctor validation.
# Doctor validation is also handled by jules-automerge.yml as a pre-merge gate.

name: Jules Workflows

on:
  schedule:
    - cron: '0 19 * * *'  # Daily at 19:00 UTC (04:00 JST)
  workflow_dispatch:
    inputs:
      entry_point:
        description: 'Start from layer'
        type: choice
        options:
          - narrator
          - observers
          - deciders
        default: narrator
      wait_minutes:
        description: 'Minutes to wait between layers (Jules async processing time)'
        type: number
        default: 30
      routing_labels:
        description: 'Issue labels eligible for planner/implementer routing (comma-separated)'
        type: string
        default: bugs,docs,tests

permissions:
  contents: write
  issues: write
  pull-requests: write

concurrency:
  group: jules
  cancel-in-progress: false

env:
  ENTRY_POINT: ${{ inputs.entry_point || 'narrator' }}
  WAIT_MINUTES: ${{ inputs.wait_minutes || 30 }}
  ROUTING_LABELS: ${{ inputs.routing_labels || 'bugs,docs,tests' }}

jobs:
  # ============================================================
  # Phase 1: Run narrator (changes feed generation)
  # ============================================================
  run-narrator:
    if: >-
      vars.JULES_PAUSED != 'true' &&
      (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch') &&
      (inputs.entry_point || 'narrator') == 'narrator'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: jules
          fetch-depth: 0

      - name: Validate .jules workspace exists
        run: |
          if [ ! -d ".jules" ]; then
            echo "::error::.jules directory is missing on the 'jules' branch."
            exit 1
          fi

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          version: ${{ vars.JLO_VERSION || 'latest' }}

      - name: Run narrator
        run: |
          timeout 20m jlo run narrator

      - name: Validate workspace (fail-fast)
        run: jlo doctor

  # ============================================================
  # Phase 2: Wait for narrator processing
  # ============================================================
  wait-after-narrator:
    needs: run-narrator
    if: (inputs.entry_point || 'narrator') == 'narrator'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        run: |
          echo "Waiting $WAIT_MINUTES minutes for Jules to process narrator PR..."
          sleep $((WAIT_MINUTES * 60))
          echo "Wait complete."

  # ============================================================
  # Phase 3: Generate workstream matrix
  # ============================================================
  generate-workstream-matrix:
    needs: wait-after-narrator
    if: |
      always() &&
      vars.JULES_PAUSED != 'true' &&
      (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch') &&
      (needs.wait-after-narrator.result == 'success' || needs.wait-after-narrator.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
      has_workstreams: ${{ steps.matrix.outputs.has_workstreams }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: jules
          fetch-depth: 0

      - name: Validate .jules workspace
        run: |
          if [ ! -d ".jules" ]; then
            echo "::error::.jules directory is missing on the 'jules' branch."
            exit 1
          fi
          if ! ls .jules/workstreams/*/scheduled.toml >/dev/null 2>&1; then
            echo "::error::No workstream scheduled.toml found under .jules/workstreams/."
            exit 1
          fi

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          version: ${{ vars.JLO_VERSION || 'latest' }}

      - name: Generate workstream matrix
        id: matrix
        run: bash .github/scripts/jules-generate-workstream-matrix.sh

  # ============================================================
  # Phase 4: Generate observer matrix (role-level)
  # ============================================================
  generate-observer-matrix:
    needs: generate-workstream-matrix
    if: >-
      needs.generate-workstream-matrix.outputs.has_workstreams == 'true' &&
      (inputs.entry_point || 'narrator') != 'deciders'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
      has_observers: ${{ steps.matrix.outputs.has_observers }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: jules
          fetch-depth: 0

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          version: ${{ vars.JLO_VERSION || 'latest' }}

      - name: Generate observer matrix
        id: matrix
        env:
          WORKSTREAMS_JSON: ${{ needs.generate-workstream-matrix.outputs.matrix }}
        run: bash .github/scripts/jules-generate-observer-matrix.sh

  # ============================================================
  # Phase 5: Run observers (sequential via max-parallel=1)
  # ============================================================
  run-observers:
    needs: [generate-workstream-matrix, generate-observer-matrix]
    if: needs.generate-observer-matrix.outputs.has_observers == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix: ${{ fromJson(needs.generate-observer-matrix.outputs.matrix) }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: jules
          fetch-depth: 0

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          version: ${{ vars.JLO_VERSION || 'latest' }}

      - name: Run observer ${{ matrix.workstream }} / ${{ matrix.role }}
        run: |
          timeout 20m jlo run observers --workstream "${{ matrix.workstream }}" --role "${{ matrix.role }}"

  # ============================================================
  # Phase 6: Wait for observer processing
  # ============================================================
  wait-after-observers:
    needs: [generate-observer-matrix, run-observers]
    if: needs.generate-observer-matrix.outputs.has_observers == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        run: |
          echo "Waiting $WAIT_MINUTES minutes for Jules to process observer PRs..."
          sleep $((WAIT_MINUTES * 60))
          echo "Wait complete."

  # ============================================================
  # Phase 7: Generate decider matrix (pending events check)
  # ============================================================
  generate-decider-matrix:
    needs: [generate-workstream-matrix, wait-after-observers]
    if: |
      always() &&
      needs.generate-workstream-matrix.outputs.has_workstreams == 'true' &&
      (needs.wait-after-observers.result == 'success' || needs.wait-after-observers.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
      has_pending: ${{ steps.matrix.outputs.has_pending }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: jules
          fetch-depth: 0

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          version: ${{ vars.JLO_VERSION || 'latest' }}

      - name: Generate decider matrix from pending events
        id: matrix
        env:
          WORKSTREAMS_JSON: ${{ needs.generate-workstream-matrix.outputs.matrix }}
        run: bash .github/scripts/jules-generate-decider-matrix.sh

  # ============================================================
  # Phase 8: Run deciders (sequential via max-parallel=1)
  # ============================================================
  run-deciders:
    needs: [generate-decider-matrix]
    if: needs.generate-decider-matrix.outputs.has_pending == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix: ${{ fromJson(needs.generate-decider-matrix.outputs.matrix) }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: jules
          fetch-depth: 0

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          version: ${{ vars.JLO_VERSION || 'latest' }}

      - name: Run decider for ${{ matrix.workstream }}
        run: |
          timeout 20m jlo run deciders --workstream "${{ matrix.workstream }}" --scheduled

  # ============================================================
  # Phase 9: Wait for decider processing
  # ============================================================
  wait-after-deciders:
    needs: [generate-decider-matrix, run-deciders]
    if: needs.generate-decider-matrix.outputs.has_pending == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        run: |
          echo "Waiting $WAIT_MINUTES minutes for Jules to process decider PRs..."
          sleep $((WAIT_MINUTES * 60))
          echo "Wait complete."

  # ============================================================
  # Phase 10: Generate planner/implementer matrix (new issues)
  # ============================================================
  generate-planner-matrix:
    needs: [generate-workstream-matrix, generate-decider-matrix, wait-after-deciders]
    if: |
      always() &&
      needs.generate-workstream-matrix.outputs.has_workstreams == 'true' &&
      (needs.wait-after-deciders.result == 'success' || needs.wait-after-deciders.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      planner_matrix: ${{ steps.matrix.outputs.planner_matrix }}
      has_planners: ${{ steps.matrix.outputs.has_planners }}
      implementer_matrix: ${{ steps.matrix.outputs.implementer_matrix }}
      has_implementers: ${{ steps.matrix.outputs.has_implementers }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: jules
          fetch-depth: 0

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          version: ${{ vars.JLO_VERSION || 'latest' }}

      - name: Generate planner and implementer matrices
        id: matrix
        env:
          WORKSTREAMS_JSON: ${{ needs.generate-workstream-matrix.outputs.matrix }}
          ROUTING_LABELS: ${{ env.ROUTING_LABELS }}
        run: bash .github/scripts/jules-generate-routing-matrices.sh

  # ============================================================
  # Phase 11: Run planners (sequential via max-parallel=1)
  # ============================================================
  run-planners:
    needs: [generate-planner-matrix]
    if: needs.generate-planner-matrix.outputs.has_planners == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix: ${{ fromJson(needs.generate-planner-matrix.outputs.planner_matrix) }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: jules
          fetch-depth: 0

      - name: Install jlo
        uses: ./.github/actions/install-jlo
        with:
          version: ${{ vars.JLO_VERSION || 'latest' }}

      - name: Run planner for ${{ matrix.issue }}
        run: |
          timeout 20m jlo run planners "${{ matrix.issue }}"

  # ============================================================
  # Phase 12: Wait for planner processing
  # ============================================================
  wait-after-planners:
    needs: [generate-planner-matrix, run-planners]
    if: needs.generate-planner-matrix.outputs.has_planners == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Wait ${{ env.WAIT_MINUTES }} minutes for Jules async processing
        run: |
          echo "Waiting $WAIT_MINUTES minutes for Jules to process planner PRs..."
          sleep $((WAIT_MINUTES * 60))
          echo "Wait complete."

  # ============================================================
  # Phase 13: Run implementers (sequential via max-parallel=1)
  # ============================================================
  run-implementers:
    needs: [generate-planner-matrix, wait-after-planners]
    if: |
      always() &&
      needs.generate-planner-matrix.outputs.has_implementers == 'true' &&
      (needs.wait-after-planners.result == 'success' || needs.wait-after-planners.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix: ${{ fromJson(needs.generate-planner-matrix.outputs.implementer_matrix) }}
    env:
      JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: jules
          fetch-depth: 0

      - name: Run implementer for ${{ matrix.issue }}
        uses: ./.github/actions/run-implementer
        with:
          issue_file: ${{ matrix.issue }}
          jlo_version: ${{ vars.JLO_VERSION || 'latest' }}
          target_branch: main
